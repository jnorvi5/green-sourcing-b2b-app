# Azure AD Authentication Debugging Guide

This guide explains how to enable and use the authentication diagnostics system for troubleshooting Azure AD sign-in failures.

## Overview

The authentication diagnostics system provides:
- **Structured logging** with detailed step-by-step tracking of the auth flow
- **Trace IDs** for correlating user-facing errors with server logs
- **Automatic redaction** of sensitive data (tokens, secrets, codes)
- **Metrics tracking** for auth attempts, successes, and failures
- **User-friendly error messages** with trace IDs for support

## Enabling Debug Mode

### Local Development

Add to your `.env` file:
```bash
AUTH_DEBUG=true
```

Restart your Next.js development server:
```bash
npm run dev
```

### Azure Container Apps (Production/Preview)

1. Go to [Azure Portal](https://portal.azure.com)
2. Navigate to your Container App (e.g., `greenchainz-frontend`)
3. Click on **Settings** → **Environment variables**
4. Add or update:
   - **Name**: `AUTH_DEBUG`
   - **Value**: `true`
5. Click **Save** and wait for the app to restart

> **Note**: Auth errors are always logged even when `AUTH_DEBUG=false`. Debug mode adds verbose step-by-step logging of successful flows.

## Authentication Flow and Logging Points

### 1. Token Exchange (`/api/auth/azure-token-exchange`)

When a user completes Azure AD sign-in and returns to your app, the backend exchanges the authorization code for access tokens using **PKCE (Proof Key for Code Exchange)** for enhanced security.

**Logged steps:**
- `init` - Token exchange initiated
- `parse-request` - Request body parsed (code, redirectUri, **codeVerifier**)
- `validate-input` - Validation of required fields (including PKCE parameters)
- `validate-config` - Azure AD environment variables check
- `token-exchange` - Calling Microsoft token endpoint with PKCE
- `token-response` - Response from Microsoft (status, errors)
- `token-success` - Successful token exchange
- `exception` - Unhandled errors

**Example log output (with PKCE):**
```json
{
  "timestamp": "2026-02-01T23:30:00.123Z",
  "level": "info",
  "message": "Calling Microsoft token endpoint",
  "traceId": "auth-1738453800123-a1b2c3d4",
  "provider": "azure",
  "step": "token-exchange",
  "metadata": {
    "tokenEndpoint": "https://login.microsoftonline.com/common/oauth2/v2.0/token",
    "redirectUri": "https://www.greenchainz.com/login/callback",
    "tenantId": "common",
    "scope": "openid profile email",
    "pkceEnabled": true
  }
}
```

> **PKCE Flow**: The frontend generates a random `code_verifier`, hashes it to create a `code_challenge`, and sends the challenge to Azure AD during authorization. When exchanging the code for tokens, the backend must include the original `code_verifier` to prove it matches the challenge.

### 2. User Callback (`/api/auth/azure-callback`)

After receiving tokens from Azure, creates or updates user in database:

**Logged steps:**
- `init` - Callback initiated
- `parse-body` - Request body parsed (email, azureId, etc.)
- `validate-input` - Validation of required fields
- `db-connect` - Database connection acquired
- `db-begin` - Transaction started
- `db-user-check` - Checking for existing user
- `db-update-user` - Updating existing user's last login
- `db-create-user` - Creating new user (if not exists)
- `db-commit` - Transaction committed
- `generate-tokens` - Generating JWT tokens
- `store-refresh-token` - Storing refresh token
- `success` - Authentication complete
- `exception` - Unhandled errors

### 3. Frontend Callback (`/app/login/callback/CallbackClient.tsx`)

Handles the OAuth redirect and calls the backend APIs:

**User-visible steps:**
- "Loading configuration..."
- "Completing Microsoft sign-in..."
- "Exchanging Microsoft authorization code with PKCE..." *(NEW)*
- "Parsing Azure identity..."
- "Finalizing sign-in on backend..."
- "Authentication successful! Redirecting..."

**PKCE Implementation Details:**

The frontend performs the following PKCE-specific operations:

1. **Extract authorization code** from URL hash: `window.location.hash`
2. **Extract state parameter** to locate the code_verifier: `hashParams.get("state")`
3. **Search sessionStorage** for the code_verifier using the state:
   ```javascript
   // MSAL stores verifier with key pattern: "{clientId}.{state}.code.verifier"
   const storageKeys = Object.keys(sessionStorage);
   for (const key of storageKeys) {
     if (key.includes(state) && key.includes('code.verifier')) {
       codeVerifier = sessionStorage.getItem(key);
       break;
     }
   }
   ```
4. **Send to backend** with both code and code_verifier:
   ```json
   {
     "code": "authorization_code_from_azure",
     "redirectUri": "https://greenchainz.com/login/callback",
     "codeVerifier": "dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk"
   }
   ```

> **Security Note**: The `code_verifier` is a cryptographically random string (43-128 chars) generated by MSAL.js. It's hashed to create the `code_challenge` sent to Azure AD. By requiring the backend to provide the original verifier, PKCE prevents authorization code interception attacks.

## Understanding PKCE Flow

### What is PKCE?

PKCE (Proof Key for Code Exchange, pronounced "pixy") is an OAuth 2.0 security extension that protects against authorization code interception attacks. It's especially important for:
- Single-page applications (SPAs)
- Mobile apps  
- Public clients (apps that can't securely store client secrets)

### How PKCE Works

1. **Frontend generates random verifier**:
   ```
   code_verifier = random_string(43-128 chars)
   ```

2. **Frontend hashes verifier to create challenge**:
   ```
   code_challenge = base64url(sha256(code_verifier))
   ```

3. **Frontend requests authorization with challenge**:
   ```
   GET /authorize?
     client_id=...
     &redirect_uri=...
     &response_type=code
     &code_challenge=ABC123...
     &code_challenge_method=S256
   ```

4. **Azure AD returns authorization code**:
   ```
   Redirect to: https://app.com/callback#code=XYZ789...
   ```

5. **Backend exchanges code with verifier**:
   ```
   POST /token
   {
     grant_type: "authorization_code",
     code: "XYZ789...",
     code_verifier: "original_random_string",  ← Must match!
     client_id: "...",
     redirect_uri: "..."
   }
   ```

6. **Azure AD validates and returns tokens**:
   - Hashes the `code_verifier`
   - Compares with stored `code_challenge`
   - Returns tokens only if they match

### Why PKCE Matters

**Without PKCE:**
- Attacker intercepts authorization code
- Attacker exchanges code for tokens
- Attacker gains access to user's account

**With PKCE:**
- Attacker intercepts authorization code
- Attacker tries to exchange code
- Azure AD rejects: "code_verifier doesn't match code_challenge"
- User's account remains secure

### PKCE in GreenChainz

Our implementation uses **hybrid flow** for maximum security:

1. **MSAL.js (frontend)** generates PKCE parameters automatically
2. **Custom backend route** exchanges code with PKCE verification
3. **Azure AD B2C** validates PKCE parameters on both requests

This provides defense-in-depth:
- ✅ PKCE protects against code interception
- ✅ Client secret protects against unauthorized token requests
- ✅ JWT validation protects against token tampering

## Viewing Logs

### Local Development

Logs appear in your terminal where `npm run dev` is running:

```bash
[AUTH] {
  "timestamp": "2026-01-15T03:30:00.123Z",
  "level": "error",
  "message": "Microsoft rejected the token exchange",
  "traceId": "auth-1736912345678-a1b2c3d4",
  "provider": "azure",
  "step": "token-rejected",
  "statusCode": 400,
  "metadata": {
    "error": "invalid_grant",
    "errorDescription": "AADSTS54005: OAuth2 Authorization code was already redeemed",
    "errorCodes": ["54005"],
    "correlationId": "abc123..."
  }
}
```

### Azure Container Apps

#### Option 1: Log Stream (Real-time)

1. Go to Azure Portal → Your Container App
2. Click **Monitoring** → **Log stream**
3. Watch logs in real-time
4. Search for `[AUTH]` to filter authentication logs

#### Option 2: Log Analytics (Historical)

1. Go to Azure Portal → Your Container App
2. Click **Monitoring** → **Logs**
3. Use Kusto queries to search logs:

```kusto
ContainerAppConsoleLogs_CL
| where Log_s contains "[AUTH]"
| where TimeGenerated > ago(1h)
| project TimeGenerated, Log_s
| order by TimeGenerated desc
| limit 100
```

Search by Trace ID:
```kusto
ContainerAppConsoleLogs_CL
| where Log_s contains "auth-1736912345678-a1b2c3d4"
| project TimeGenerated, Log_s
| order by TimeGenerated asc
```

#### Option 3: Azure CLI

```bash
# Stream logs in real-time
az containerapp logs show \
  --name greenchainz-frontend \
  --resource-group greenchainz-prod \
  --follow

# Filter for auth logs
az containerapp logs show \
  --name greenchainz-frontend \
  --resource-group greenchainz-prod \
  --follow | grep '\[AUTH\]'
```

## Common Issues and Solutions

### Issue: "PKCE code_verifier is required" (NEW)

**Error Code:** HTTP 400  
**Trace ID helps find:** Whether the frontend sent the code_verifier

**Check logs for:**
- `step: "parse-request"` - Was code_verifier present?
- `metadata.hasCodeVerifier` - Should be `true`

**Common causes:**
- Frontend failed to extract code_verifier from sessionStorage
- MSAL.js not properly initialized before redirect
- Authorization flow not initiated correctly (direct URL navigation)
- SessionStorage cleared between authorization and callback

**Solution:**
1. Ensure MSAL.js is initialized before calling `loginRedirect()`
2. Check browser console for errors during authorization
3. Verify sessionStorage permissions in browser
4. Don't use "Open in new tab" - let the auth flow handle redirects

### Issue: "AADSTS50148: code_verifier doesn't match code_challenge" (FIXED)

**Error Code:** `invalid_grant` with error code 50148  
**This was the PKCE mismatch bug - now fixed!**

**What it means:**
- The `code_verifier` sent to Microsoft doesn't match the `code_challenge` from the authorization request
- This is a PKCE security check to prevent authorization code interception attacks

**How we fixed it:**
1. ✅ Backend now accepts `code_verifier` parameter
2. ✅ Backend includes `code_verifier` in token exchange request
3. ✅ Frontend extracts `code_verifier` from MSAL sessionStorage
4. ✅ Frontend sends both `code` and `code_verifier` to backend

**If you still see this error:**
- Clear browser cache and sessionStorage
- Try signing in again from the beginning
- Check that you're using the latest code from this PR

### Issue: "Authorization code is required"

**Trace ID helps find:** Whether the code was sent from frontend

**Check logs for:**
- `step: "parse-request"` - Was code present?
- `metadata.hasCode` - Should be `true`

**Common causes:**
- User denied consent in Azure AD
- OAuth redirect URL mismatch
- State parameter tampering

### Issue: "Microsoft rejected the token exchange"

**Trace ID helps find:** The exact error from Microsoft

**Check logs for:**
- `step: "token-rejected"`
- `metadata.error` - Azure AD error code
- `metadata.errorDescription` - Human-readable error
- `metadata.correlationId` - Microsoft's correlation ID

**Common errors:**
- `invalid_grant` / `AADSTS54005` - Code already used (refresh page)
- `invalid_grant` / `AADSTS50148` - PKCE mismatch (see above)
- `invalid_client` - Wrong client ID/secret
- `redirect_uri_mismatch` - Redirect URI doesn't match Azure app registration

### Issue: "Database connection failed"

**Trace ID helps find:** Which database operation failed

**Check logs for:**
- `step: "db-connect"` - Connection pool issue
- `step: "db-user-check"` - Query failed
- `step: "db-rollback"` - Transaction rolled back

**Common causes:**
- Database connection pool exhausted
- Database credentials incorrect
- Network connectivity to Azure PostgreSQL

### Issue: "Token exchange failed (HTTP 502)"

**This means:** Backend service is unreachable

**Check:**
1. Is the backend container running?
   ```bash
   az containerapp show \
     --name greenchainz-frontend \
     --resource-group greenchainz-prod \
     --query "properties.runningStatus"
   ```

2. Are environment variables set correctly?
   - `AZURE_CLIENT_ID`
   - `AZURE_CLIENT_SECRET`
   - `AZURE_TENANT_ID`

## Using Trace IDs for Support

When users report authentication failures, they'll see an error like:

```
Authentication failed: Token exchange failed (Trace ID: auth-1736912345678-a1b2c3d4)
```

### To investigate:

1. **Copy the Trace ID** from the user's error message
2. **Search logs** in Azure Log Analytics:
   ```kusto
   ContainerAppConsoleLogs_CL
   | where Log_s contains "auth-1736912345678-a1b2c3d4"
   | project TimeGenerated, Log_s
   | order by TimeGenerated asc
   ```
3. **Review the flow** - All log entries with that trace ID show the complete auth flow
4. **Find the failure point** - Look for `level: "error"` entries

## Metrics

When `AUTH_DEBUG=true`, the system logs metrics for:
- `auth_attempt` - User started authentication
- `auth_success` - Authentication completed successfully
- `auth_failure` - Authentication failed (with reason)

These can be aggregated for monitoring:

```kusto
ContainerAppConsoleLogs_CL
| where Log_s contains "[AUTH_METRIC]"
| extend metric = extract("\"metric\":\"([^\"]+)\"", 1, Log_s)
| extend provider = extract("\"provider\":\"([^\"]+)\"", 1, Log_s)
| summarize count() by metric, provider
```

## Security Notes

The diagnostics system automatically redacts:
- Access tokens
- ID tokens
- Refresh tokens
- Authorization codes
- Client secrets
- API keys
- Passwords

Redacted values appear as `[REDACTED X chars]` in logs.

**Example:**
```json
{
  "access_token": "[REDACTED 1843 chars]",
  "id_token": "[REDACTED 912 chars]",
  "code": "[REDACTED 156 chars]"
}
```

## Disabling Debug Mode

To disable verbose logging:

### Local Development
Remove or set in `.env`:
```bash
AUTH_DEBUG=false
```

### Azure Container Apps
1. Go to Azure Portal → Container App → Environment variables
2. Set `AUTH_DEBUG` to `false` or delete the variable
3. Save and restart

> **Note**: Error logs will still be captured even when debug mode is off.

## Best Practices

1. **Enable debug mode only when troubleshooting** - Reduces log volume and costs
2. **Always include trace ID when filing support tickets**
3. **Check Azure AD audit logs** for complementary information:
   - Go to Azure Portal → Azure Active Directory → Sign-in logs
   - Search by user email or correlation ID
4. **Monitor authentication metrics** to identify patterns
5. **Review logs regularly** to catch issues before users report them

## Related Documentation

- [Azure AD OAuth Setup](./OAUTH_SETUP.md) - Configuring Azure AD app registration
- [Azure Secrets and Config](./AZURE_SECRETS_AND_CONFIG.md) - Managing environment variables
- [Production Setup Checklist](./PRODUCTION-SETUP-CHECKLIST.md) - Deployment guide

## Support

If authentication issues persist after following this guide:
1. Collect the trace ID from the error message
2. Export relevant logs from Azure Log Analytics
3. Check Azure AD sign-in logs for the user/time period
4. Contact support with all of the above information
