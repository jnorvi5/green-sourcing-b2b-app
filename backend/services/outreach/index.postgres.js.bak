/**
 * Outreach Agent Service - Main Entry Point
 * 
 * Coordinates all outreach automation:
 * - Lead management
 * - AI email generation
 * - Email delivery
 * - Campaign tracking
 * - Analytics
 */

const LeadService = require('./leadService');
const EmailGenerator = require('./emailGenerator');
const EmailSender = require('./emailSender');
const CampaignManager = require('./campaignManager');
const AgentRunner = require('./agentRunner');
const Analytics = require('./analytics');

class OutreachService {
    constructor(dbPool) {
        this.pool = dbPool;
        this.leadService = new LeadService(dbPool);
        this.emailGenerator = new EmailGenerator();
        this.emailSender = new EmailSender();
        this.campaignManager = new CampaignManager(dbPool);
        this.analytics = new Analytics(dbPool);
        this.agentRunner = new AgentRunner(this);

        this.initialized = false;
    }

    /**
     * Initialize the outreach service
     * Creates necessary tables and starts the cron scheduler
     */
    async initialize() {
        if (this.initialized) return;

        console.log('[Outreach] Initializing service...');

        // Create database tables
        await this.createTables();

        // Start cron scheduler
        this.agentRunner.startScheduler();

        this.initialized = true;
        console.log('[Outreach] Service initialized successfully');
    }

    /**
     * Create outreach database tables if they don't exist
     */
    async createTables() {
        const queries = [
            // Contacts/Leads table
            `CREATE TABLE IF NOT EXISTS Outreach_Contacts (
        ContactID SERIAL PRIMARY KEY,
        Email VARCHAR(255) UNIQUE NOT NULL,
        FirstName VARCHAR(100),
        LastName VARCHAR(100),
        Company VARCHAR(255),
        JobTitle VARCHAR(255),
        Phone VARCHAR(50),
        LinkedInURL VARCHAR(500),
        Website VARCHAR(500),
        ContactType VARCHAR(50) DEFAULT 'lead', -- lead, supplier, buyer, partner
        Source VARCHAR(100), -- website, linkedin, referral, import
        LeadScore INTEGER DEFAULT 0,
        Status VARCHAR(50) DEFAULT 'new', -- new, contacted, engaged, converted, unsubscribed, bounced
        Tags TEXT[], -- array of tags
        CustomFields JSONB DEFAULT '{}',
        LastContactedAt TIMESTAMP,
        CreatedAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        UpdatedAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )`,

            // Campaigns table
            `CREATE TABLE IF NOT EXISTS Outreach_Campaigns (
        CampaignID SERIAL PRIMARY KEY,
        Name VARCHAR(255) NOT NULL,
        Description TEXT,
        CampaignType VARCHAR(50) DEFAULT 'drip', -- drip, blast, trigger
        TargetAudience VARCHAR(50), -- suppliers, buyers, all
        Status VARCHAR(50) DEFAULT 'draft', -- draft, active, paused, completed
        StartDate TIMESTAMP,
        EndDate TIMESTAMP,
        Settings JSONB DEFAULT '{}',
        CreatedBy INTEGER,
        CreatedAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        UpdatedAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )`,

            // Sequence steps table
            `CREATE TABLE IF NOT EXISTS Outreach_Sequences (
        SequenceID SERIAL PRIMARY KEY,
        CampaignID INTEGER REFERENCES Outreach_Campaigns(CampaignID) ON DELETE CASCADE,
        StepNumber INTEGER NOT NULL,
        DelayDays INTEGER DEFAULT 0,
        EmailSubject VARCHAR(500),
        EmailTemplate TEXT,
        TemplateVariables JSONB DEFAULT '{}',
        Conditions JSONB DEFAULT '{}', -- e.g., {"skipIfOpened": true}
        CreatedAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )`,

            // Outreach events table (email sends, opens, clicks, replies)
            `CREATE TABLE IF NOT EXISTS Outreach_Events (
        EventID SERIAL PRIMARY KEY,
        ContactID INTEGER REFERENCES Outreach_Contacts(ContactID) ON DELETE CASCADE,
        CampaignID INTEGER REFERENCES Outreach_Campaigns(CampaignID) ON DELETE SET NULL,
        SequenceID INTEGER REFERENCES Outreach_Sequences(SequenceID) ON DELETE SET NULL,
        EventType VARCHAR(50) NOT NULL, -- sent, delivered, opened, clicked, replied, bounced, unsubscribed
        EmailSubject VARCHAR(500),
        EmailBody TEXT,
        MessageID VARCHAR(255), -- For tracking
        Metadata JSONB DEFAULT '{}',
        Timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )`,

            // Agent run logs
            `CREATE TABLE IF NOT EXISTS Outreach_Agent_Runs (
        RunID SERIAL PRIMARY KEY,
        RunType VARCHAR(50) DEFAULT 'scheduled', -- scheduled, manual, trigger
        Status VARCHAR(50) DEFAULT 'running', -- running, completed, failed
        ContactsProcessed INTEGER DEFAULT 0,
        EmailsSent INTEGER DEFAULT 0,
        Errors JSONB DEFAULT '[]',
        StartedAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        CompletedAt TIMESTAMP,
        DurationMs INTEGER
      )`,

            // Contact-Campaign enrollment
            `CREATE TABLE IF NOT EXISTS Outreach_Enrollments (
        EnrollmentID SERIAL PRIMARY KEY,
        ContactID INTEGER REFERENCES Outreach_Contacts(ContactID) ON DELETE CASCADE,
        CampaignID INTEGER REFERENCES Outreach_Campaigns(CampaignID) ON DELETE CASCADE,
        CurrentStep INTEGER DEFAULT 1,
        Status VARCHAR(50) DEFAULT 'active', -- active, paused, completed, exited
        EnrolledAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        LastStepAt TIMESTAMP,
        ExitReason VARCHAR(255),
        UNIQUE(ContactID, CampaignID)
      )`,

            // Agent Instructions table - lets you feed custom instructions to the agent
            `CREATE TABLE IF NOT EXISTS Outreach_Agent_Instructions (
        InstructionID SERIAL PRIMARY KEY,
        Name VARCHAR(255) NOT NULL,
        InstructionType VARCHAR(50) DEFAULT 'general', -- general, tone, targeting, exclusion, template
        Instructions TEXT NOT NULL,
        IsActive BOOLEAN DEFAULT true,
        Priority INTEGER DEFAULT 0, -- Higher = more important
        AppliesTo VARCHAR(50) DEFAULT 'all', -- all, suppliers, buyers, specific_campaign
        CampaignID INTEGER REFERENCES Outreach_Campaigns(CampaignID) ON DELETE SET NULL,
        CreatedBy INTEGER,
        CreatedAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        UpdatedAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )`,

            // Processed sources tracking - prevents re-scraping same sources
            `CREATE TABLE IF NOT EXISTS Outreach_Processed_Sources (
        SourceID SERIAL PRIMARY KEY,
        SourceType VARCHAR(50) NOT NULL, -- linkedin, website, csv, api
        SourceIdentifier VARCHAR(500) NOT NULL, -- URL, filename, API endpoint
        SourceHash VARCHAR(64), -- Hash of content to detect changes
        RecordsFound INTEGER DEFAULT 0,
        RecordsImported INTEGER DEFAULT 0,
        ProcessedAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        Metadata JSONB DEFAULT '{}',
        UNIQUE(SourceType, SourceIdentifier)
      )`,

            // Indexes for performance
            `CREATE INDEX IF NOT EXISTS idx_contacts_email ON Outreach_Contacts(Email)`,
            `CREATE INDEX IF NOT EXISTS idx_contacts_status ON Outreach_Contacts(Status)`,
            `CREATE INDEX IF NOT EXISTS idx_contacts_type ON Outreach_Contacts(ContactType)`,
            `CREATE INDEX IF NOT EXISTS idx_events_contact ON Outreach_Events(ContactID)`,
            `CREATE INDEX IF NOT EXISTS idx_events_type ON Outreach_Events(EventType)`,
            `CREATE INDEX IF NOT EXISTS idx_events_timestamp ON Outreach_Events(Timestamp)`,
            `CREATE INDEX IF NOT EXISTS idx_enrollments_status ON Outreach_Enrollments(Status)`
        ];

        for (const query of queries) {
            try {
                await this.pool.query(query);
            } catch (err) {
                // Ignore "already exists" errors
                if (!err.message.includes('already exists')) {
                    console.error('[Outreach] Table creation error:', err.message);
                }
            }
        }
    }

    // ==========================================
    // LEAD MANAGEMENT
    // ==========================================

    async addContact(contactData) {
        return this.leadService.addContact(contactData);
    }

    async getContacts(filters = {}) {
        return this.leadService.getContacts(filters);
    }

    async getContact(contactId) {
        return this.leadService.getContact(contactId);
    }

    async updateContact(contactId, updates) {
        return this.leadService.updateContact(contactId, updates);
    }

    async importContacts(contacts, source = 'import') {
        return this.leadService.importContacts(contacts, source);
    }

    // ==========================================
    // CAMPAIGN MANAGEMENT
    // ==========================================

    async createCampaign(campaignData) {
        return this.campaignManager.createCampaign(campaignData);
    }

    async getCampaigns(filters = {}) {
        return this.campaignManager.getCampaigns(filters);
    }

    async enrollContact(contactId, campaignId) {
        return this.campaignManager.enrollContact(contactId, campaignId);
    }

    // ==========================================
    // OUTREACH EVENTS
    // ==========================================

    async getEvents(filters = {}) {
        return this.analytics.getEvents(filters);
    }

    async logEvent(eventData) {
        return this.analytics.logEvent(eventData);
    }

    // ==========================================
    // AGENT OPERATIONS
    // ==========================================

    async runAgent(options = {}) {
        return this.agentRunner.run(options);
    }

    async getAgentRuns(limit = 20) {
        return this.agentRunner.getRunHistory(limit);
    }

    // ==========================================
    // ANALYTICS
    // ==========================================

    async getAnalytics(period = 'last_30_days') {
        return this.analytics.getSummary(period);
    }

    async getCampaignAnalytics(campaignId) {
        return this.analytics.getCampaignStats(campaignId);
    }

    // ==========================================
    // AGENT INSTRUCTIONS (Feed custom instructions)
    // ==========================================

    /**
     * Get all active instructions as a key-value map
     * Used by AgentRunner before generating emails
     */
    async getActiveInstructions() {
        const result = await this.pool.query(`
            SELECT Name as key, Instructions as value, InstructionType, Priority
            FROM Outreach_Agent_Instructions 
            WHERE IsActive = true
            ORDER BY Priority DESC
        `);

        // Return as object { key: value }
        const instructions = {};
        for (const row of result.rows) {
            instructions[row.key] = row.value;
        }
        return instructions;
    }

    /**
     * Get a single instruction by key (name)
     */
    async getInstruction(key) {
        const result = await this.pool.query(
            'SELECT * FROM Outreach_Agent_Instructions WHERE LOWER(Name) = LOWER($1)',
            [key]
        );
        return result.rows[0] || null;
    }

    /**
     * Set (create or update) an instruction
     */
    async setInstruction(key, value, options = {}) {
        const {
            description,
            isActive = true,
            priority = 0,
            createdBy = null,
            instructionType = 'general',
            appliesTo = 'all',
            campaignId = null
        } = options;

        const existing = await this.getInstruction(key);

        if (existing) {
            // Update
            const result = await this.pool.query(`
                UPDATE Outreach_Agent_Instructions 
                SET Instructions = $1, IsActive = $2, Priority = $3, UpdatedAt = CURRENT_TIMESTAMP,
                    InstructionType = COALESCE($4, InstructionType),
                    AppliesTo = COALESCE($5, AppliesTo)
                WHERE LOWER(Name) = LOWER($6)
                RETURNING *
            `, [value, isActive, priority, instructionType, appliesTo, key]);
            return result.rows[0];
        } else {
            // Create
            const result = await this.pool.query(`
                INSERT INTO Outreach_Agent_Instructions 
                (Name, Instructions, IsActive, Priority, InstructionType, AppliesTo, CampaignID, CreatedBy)
                VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
                RETURNING *
            `, [key, value, isActive, priority, instructionType, appliesTo, campaignId, createdBy]);
            return result.rows[0];
        }
    }

    /**
     * Delete an instruction by key
     */
    async deleteInstructionByKey(key) {
        await this.pool.query(
            'DELETE FROM Outreach_Agent_Instructions WHERE LOWER(Name) = LOWER($1)',
            [key]
        );
        return { success: true };
    }

    /**
     * Add new instruction for the agent
     */
    async addInstruction(instructionData) {
        const {
            name,
            instructionType = 'general',
            instructions,
            isActive = true,
            priority = 0,
            appliesTo = 'all',
            campaignId = null,
            createdBy = null
        } = instructionData;

        if (!name || !instructions) {
            throw new Error('Name and instructions are required');
        }

        const result = await this.pool.query(`
            INSERT INTO Outreach_Agent_Instructions 
            (Name, InstructionType, Instructions, IsActive, Priority, AppliesTo, CampaignID, CreatedBy)
            VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
            RETURNING *
        `, [name, instructionType, instructions, isActive, priority, appliesTo, campaignId, createdBy]);

        return { success: true, instruction: result.rows[0] };
    }

    /**
     * Get all active instructions (optionally filtered)
     */
    async getInstructions(filters = {}) {
        const { type, appliesTo, campaignId, activeOnly = true } = filters;

        let whereConditions = [];
        const params = [];
        let paramIndex = 1;

        if (activeOnly) {
            whereConditions.push('IsActive = true');
        }

        if (type) {
            whereConditions.push(`InstructionType = $${paramIndex}`);
            params.push(type);
            paramIndex++;
        }

        if (appliesTo) {
            whereConditions.push(`(AppliesTo = $${paramIndex} OR AppliesTo = 'all')`);
            params.push(appliesTo);
            paramIndex++;
        }

        if (campaignId) {
            whereConditions.push(`(CampaignID = $${paramIndex} OR CampaignID IS NULL)`);
            params.push(campaignId);
            paramIndex++;
        }

        const whereClause = whereConditions.length > 0
            ? 'WHERE ' + whereConditions.join(' AND ')
            : '';

        const result = await this.pool.query(`
            SELECT * FROM Outreach_Agent_Instructions
            ${whereClause}
            ORDER BY Priority DESC, CreatedAt ASC
        `, params);

        return result.rows;
    }

    /**
     * Update an instruction
     */
    async updateInstruction(instructionId, updates) {
        const allowedFields = ['Name', 'InstructionType', 'Instructions', 'IsActive', 'Priority', 'AppliesTo', 'CampaignID'];
        const setClauses = ['UpdatedAt = CURRENT_TIMESTAMP'];
        const params = [];
        let paramIndex = 1;

        for (const [key, value] of Object.entries(updates)) {
            const fieldName = key.charAt(0).toUpperCase() + key.slice(1);
            if (allowedFields.includes(fieldName)) {
                setClauses.push(`${fieldName} = $${paramIndex}`);
                params.push(value);
                paramIndex++;
            }
        }

        params.push(instructionId);

        const result = await this.pool.query(`
            UPDATE Outreach_Agent_Instructions
            SET ${setClauses.join(', ')}
            WHERE InstructionID = $${paramIndex}
            RETURNING *
        `, params);

        return result.rows[0];
    }

    /**
     * Delete an instruction
     */
    async deleteInstruction(instructionId) {
        await this.pool.query(
            'DELETE FROM Outreach_Agent_Instructions WHERE InstructionID = $1',
            [instructionId]
        );
        return { success: true };
    }

    /**
     * Get compiled instructions for the AI (combines all active instructions)
     */
    async getCompiledInstructions(context = {}) {
        const { targetAudience, campaignId } = context;

        const instructions = await this.getInstructions({
            appliesTo: targetAudience,
            campaignId,
            activeOnly: true
        });

        if (instructions.length === 0) {
            return null;
        }

        // Group by type
        const grouped = {};
        for (const inst of instructions) {
            if (!grouped[inst.instructiontype]) {
                grouped[inst.instructiontype] = [];
            }
            grouped[inst.instructiontype].push(inst.instructions);
        }

        // Compile into a single instruction block
        let compiled = '';

        if (grouped.general) {
            compiled += '## General Instructions\n' + grouped.general.join('\n') + '\n\n';
        }
        if (grouped.tone) {
            compiled += '## Tone & Voice\n' + grouped.tone.join('\n') + '\n\n';
        }
        if (grouped.targeting) {
            compiled += '## Targeting Rules\n' + grouped.targeting.join('\n') + '\n\n';
        }
        if (grouped.exclusion) {
            compiled += '## Exclusions (Do NOT contact)\n' + grouped.exclusion.join('\n') + '\n\n';
        }
        if (grouped.template) {
            compiled += '## Template Guidelines\n' + grouped.template.join('\n') + '\n\n';
        }

        return compiled.trim();
    }

    // ==========================================
    // DEDUPLICATION & SOURCE TRACKING
    // ==========================================

    /**
     * Check if a contact already exists in the database
     */
    async contactExists(email) {
        const result = await this.pool.query(
            'SELECT ContactID, Email, Status, LastContactedAt FROM Outreach_Contacts WHERE LOWER(Email) = LOWER($1)',
            [email]
        );
        return result.rows.length > 0 ? result.rows[0] : null;
    }

    /**
     * Check multiple emails at once for deduplication
     */
    async checkDuplicates(emails) {
        if (!emails || emails.length === 0) return { existing: [], new: [] };

        const lowerEmails = emails.map(e => e.toLowerCase().trim());

        const result = await this.pool.query(
            'SELECT LOWER(Email) as email FROM Outreach_Contacts WHERE LOWER(Email) = ANY($1)',
            [lowerEmails]
        );

        const existingSet = new Set(result.rows.map(r => r.email));

        return {
            existing: lowerEmails.filter(e => existingSet.has(e)),
            new: lowerEmails.filter(e => !existingSet.has(e)),
            existingCount: existingSet.size,
            newCount: lowerEmails.length - existingSet.size
        };
    }

    /**
     * Mark a source as processed (prevents re-scraping)
     */
    async markSourceProcessed(sourceType, sourceIdentifier, metadata = {}) {
        const result = await this.pool.query(`
            INSERT INTO Outreach_Processed_Sources 
            (SourceType, SourceIdentifier, RecordsFound, RecordsImported, Metadata)
            VALUES ($1, $2, $3, $4, $5)
            ON CONFLICT (SourceType, SourceIdentifier) DO UPDATE SET
                RecordsFound = EXCLUDED.RecordsFound,
                RecordsImported = EXCLUDED.RecordsImported,
                ProcessedAt = CURRENT_TIMESTAMP,
                Metadata = Outreach_Processed_Sources.Metadata || EXCLUDED.Metadata
            RETURNING *
        `, [
            sourceType,
            sourceIdentifier,
            metadata.recordsFound || 0,
            metadata.recordsImported || 0,
            JSON.stringify(metadata)
        ]);

        return result.rows[0];
    }

    /**
     * Check if a source has been processed before
     */
    async isSourceProcessed(sourceType, sourceIdentifier) {
        const result = await this.pool.query(
            'SELECT * FROM Outreach_Processed_Sources WHERE SourceType = $1 AND SourceIdentifier = $2',
            [sourceType, sourceIdentifier]
        );
        return result.rows.length > 0 ? result.rows[0] : null;
    }

    /**
     * Get all processed sources
     */
    async getProcessedSources(sourceType = null) {
        let query = 'SELECT * FROM Outreach_Processed_Sources';
        const params = [];

        if (sourceType) {
            query += ' WHERE SourceType = $1';
            params.push(sourceType);
        }

        query += ' ORDER BY ProcessedAt DESC';

        const result = await this.pool.query(query, params);
        return result.rows;
    }

    /**
     * Smart import - checks for duplicates and tracks source
     */
    async smartImport(contacts, source = {}) {
        const { type = 'import', identifier = `manual_${Date.now()}` } = source;

        // Check if this source was already processed
        const existingSource = await this.isSourceProcessed(type, identifier);
        if (existingSource) {
            return {
                skipped: true,
                reason: 'Source already processed',
                previousImport: existingSource
            };
        }

        // Check for duplicates
        const emails = contacts.map(c => c.email).filter(Boolean);
        const dupeCheck = await this.checkDuplicates(emails);

        // Filter to only new contacts
        const newContacts = contacts.filter(c =>
            c.email && dupeCheck.new.includes(c.email.toLowerCase().trim())
        );

        // Import only new contacts
        const importResult = await this.leadService.importContacts(newContacts, type);

        // Mark source as processed
        await this.markSourceProcessed(type, identifier, {
            recordsFound: contacts.length,
            recordsImported: importResult.imported,
            duplicatesSkipped: dupeCheck.existingCount,
            errors: importResult.errors
        });

        return {
            success: true,
            source: { type, identifier },
            totalProvided: contacts.length,
            duplicatesSkipped: dupeCheck.existingCount,
            imported: importResult.imported,
            updated: importResult.updated,
            failed: importResult.failed,
            errors: importResult.errors
        };
    }

    /**
     * Get database summary (what's already in the DB)
     */
    async getDatabaseSummary() {
        const [
            contactsResult,
            statusResult,
            typeResult,
            recentResult,
            sourcesResult
        ] = await Promise.all([
            this.pool.query('SELECT COUNT(*) as total FROM Outreach_Contacts'),
            this.pool.query(`
                SELECT Status, COUNT(*) as count 
                FROM Outreach_Contacts 
                GROUP BY Status
            `),
            this.pool.query(`
                SELECT ContactType, COUNT(*) as count 
                FROM Outreach_Contacts 
                GROUP BY ContactType
            `),
            this.pool.query(`
                SELECT Email, Company, ContactType, Status, CreatedAt 
                FROM Outreach_Contacts 
                ORDER BY CreatedAt DESC 
                LIMIT 10
            `),
            this.pool.query('SELECT * FROM Outreach_Processed_Sources ORDER BY ProcessedAt DESC LIMIT 10')
        ]);

        return {
            totalContacts: parseInt(contactsResult.rows[0].total),
            byStatus: statusResult.rows.reduce((acc, r) => {
                acc[r.status] = parseInt(r.count);
                return acc;
            }, {}),
            byType: typeResult.rows.reduce((acc, r) => {
                acc[r.contacttype] = parseInt(r.count);
                return acc;
            }, {}),
            recentContacts: recentResult.rows,
            processedSources: sourcesResult.rows,
            generatedAt: new Date().toISOString()
        };
    }
}

module.exports = OutreachService;
